[[junit5]]
== Overview of JUnit 5

JUnit 5 consists of a number of discrete components:

* JUnit Platform - foundation layer which enables different testing frameworks to be launched on the JVM
* Junit Jupiter - is the JUnit 5 test framework which is launched by JUnit Platform
* JUnit Vintage - legacy TestEngine which runs older tests

=== Usage of JUnit 5 in Gradle

[source,groovy]
----
buildscript {
    repositories {
        mavenCentral()
        // The following is only necessary if you want to use SNAPSHOT releases.
        // maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
    }
    dependencies {
        classpath 'org.junit.platform:junit-platform-gradle-plugin:1.0.0-M4'
    }
}

apply plugin: 'org.junit.platform.gradle.plugin'
----

[note]
====
The above works for Java projects but not yet for Android projects.
====


[[usingjunit_annotations]]
=== Defining test methods

(((JUnit,Annotations)))
(((Test annotations from JUnit)))
JUnit uses annotations to mark methods as test methods and to configure them.
The following table gives an overview of the most important annotations in JUnit for the 4.x and 5.x versions.
All these annotations can be used on methods.


.Annotations
[cols="2,4",options="header"]
|===

|`import org.junit.jupiter.api.*`
| Import statement for using the following annotations.

|`@Test`
|Identifies a method as a test method.

|`@BeforeEach`
|Executed before each test. It is used to
prepare the test environment (e.g., read input
data, initialize the class).

|`@AfterEach`
|Executed after each test. It is used to cleanup the test environment (e.g., delete temporary data, restore defaults). It can also save memory by cleaning up expensive memory structures.

|`@BeforeAll`
|Executed once, before the start of all tests.
It is used to perform time intensive activities, for example, to connect to a database. Methods marked with this annotation need to be defined as `static` to work with JUnit.

|`@AfterEach`
|Executed once, after all tests have been finished.
It is used to perform clean-up activities, for example, to disconnect from a database. Methods annotated with this annotation need to be defined as `static` to work with JUnit.

|`@Disabled` or `@Disabled("Why disabled")`
|Marks that the test should be disabled. This is useful when the
underlying code has been changed and the test case has not
yet
been
adapted. Or if the execution time of this test is too long
to be
included. It is best practice to provide
the optional
description, why the test is disabled.

|===

[[usingjunit_asserts]]
=== Assert statements

(((JUnit,Assert statements)))
JUnit provides static methods to test for certain conditions via the `Assert` class. 
These _assert statements_ typically start with `assert`.
They allow you to specify the error message, the expected and the actual result.
An _assertion method_ compares the actual value returned by  a test to the expected value.
It throws an `AssertionException` if the comparison fails.

The following table gives an overview of these methods.
Parameters in [] brackets are optional and of type String.

.Methods to assert test results
|===
|Statement | Description

|fail(message)
|Let the method fail. Might be used to check that a certain part of the code is not reached or to have a failing test before the test code is implemented.
The message parameter is optional.

|assertTrue([message,] boolean condition)
|Checks that the boolean condition is true.

|assertFalse([message,] boolean condition)
|Checks that the boolean condition is false.

|assertEquals([message,] expected, actual)
|Tests that two values are the same. Note: for arrays the reference is checked not the content of the arrays.

|assertEquals([message,] expected, actual, tolerance)
|Test that float or double values match. The tolerance is the number of decimals which must be the same.

|assertNull([message,] object)
|Checks that the object is null.

|assertNotNull([message,] object)
|Checks that the object is not null.

|assertSame([message,] expected, actual)
|Checks that both variables refer to the same object.

|assertNotSame([message,] expected, actual)
|Checks that both variables refer to different objects.
|===

		
[[juniteclipse_testsuite]]
=== JUnit test suites

(((JUnit,Test suite)))		
If you have several test classes, you can combine them into a test suite.
Running a test suite executes all test classes in that suite in the specified order.
A test suite can also contain other test suites. 
		
The following example code demonstrates the usage of a test suite. 
It  contains two test classes (MyClassTest and MySecondClassTest).
If you want to add another test class, you can add it to the `@Suite.SuiteClasses` statement.
		
[source,java]
----
include::res/example/AllTests.java[]
----

[[usingjunit_executionorder]]

=== Disabling tests

The @Disable annotation allow to statically ignore a test.

Alternatively  you can use `Assume.assumeFalse` or `Assume.assumeTrue` to define a condition for the test.
`Assume.assumeFalse` marks the test as invalid, if its condition evaluates to true.
`Assume.assumeTrue` evaluates the test as invalid if its condition evaluates  to false. 
For example, the following disables a test on Linux:

[source,java]
----
Assume.assumeFalse(System.getProperty("os.name").contains("Linux"));
----

=== Test Suites

To run multiple tests together, you can use test suites.
They allow to aggregate multiple test classes. 
JUnit 5 provides two annotations: 
* `@SelectPackages` - used to specify the names of packages for the test suite
* `@SelectClasses` - used to specify the classes for the test suite. They can be located in different packages.

[source,java]
----
@RunWith(JUnitPlatform.class)
@SelectPackages("com.vogella.junit5.examples")
public class AllTests {}
----

[source,java]
----	
@RunWith(JUnitPlatform.class)
@SelectClasses({AssertionTest.class, AssumptionTest.class, ExceptionTest.class})
public class AllTests {}
----

