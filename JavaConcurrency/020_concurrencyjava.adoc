== Concurrency in Java

=== Processes and Threads
		
A Java program runs in its own process and by default in one
thread.
Java supports threads as part of the Java language via the
`Thread`
code.
The Java application can create new threads via this class.
		
Java 1.5
also
provides improved support for concurrency with the in the
`java.util.concurrent`
package.
		
=== Locks and thread synchronization
		
Java provides
_locks_
to protect certain parts of the code to be executed by
several
threads at the same time. The simplest way of
locking a certain method
or Java class is to define the method or class with the
`synchronized`
keyword.
		
The
_synchronized_
keyword in Java ensures:

* that only a single thread can execute a block of code at the same time
* that each thread entering a synchronized block of code sees the effects of all previous modifications that were guarded by the same lock
		
Synchronization is necessary for mutually exclusive access to blocks of and for reliable communication between threads.
		
You can use the
_synchronized_
keyword for the definition of a
method. This would
ensure that only one
thread can enter this
method at the same time. Another threads which
is
calling this method would wait until the first threads leaves this
method.
		
[source,java]
----
include::res/synchronized/Method.java[]
----
		
You can also use the
`synchronized`
keyword to protect blocks of code within a method. This block is
guarded by a key,
which can be either a
string
or an object. This key is
called the
_lock_.

All code
which
is protected by
the same lock
can only
be executed
by one
thread at the same time
		
For example the following datastructure will ensure that only
one
thread can access the inner block of the
`add()`
and
`next()`
methods.
		
[source,java]
----
include::res/synchronized/CrawledSites.java[]
----
		
=== Volatile
		
If a variable is declared with the _volatile_ keyword then it is guaranteed that any thread that reads the field will see the most recently written value.
The _volatile_ keyword will not perform any mutual exclusive lock on the variable.
		
As of Java 5 write access to a _volatile_ variable will also update non-volatile variables which were modified by the same thread.
This can also be used to update values within a reference variable, e.g. for a _volatile_ variable person. 
In this case you must use a temporary variable person and use the setter to initialize the variable and then assign the temporary variable to the final variable. 
This will then make the address changes of this variable and the values visible to other threads.
		
