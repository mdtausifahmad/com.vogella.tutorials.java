[[mockitousage]]
== Using the Mockito API

=== Static imports

If you add a static import for `org.mockito.Mockito.*;`, you can access Mockitos methods like `mock()` directly. 
Static imports allow you to call static members, i.e., methods and fields of a class directly without specifying the class.
		
=== Creating and configuring mock objects with Mockito

Mockito supports the creation of mock objects. 
For this you can use the static `mock()` method.

Mockito also supports the creation of mock objects based on the `@Mock` annotation.
        
If you use this annotation, you must initialize the mock objects. 
The `MockitoRule` allows this. 
It invokes the static method `MockitoAnnotations.initMocks(this)` to populate the annotated fields. 
Alternatively you can use `@RunWith(MockitoJUnitRunner.class)`.

The usage of the `@Mock` annotation and the `MockitoRule` rule is demonstrated by the following example.

[source,java]
----
include::res/simple/TestSimple.txt[]
----   

<1> Tells Mockito to mock the databaseMock instance
<2> Tells Mockito to create the mocks based on the @Mock annotation
<3> Instantiates the class under test using the created mock
<4> Executes some code of the class under test
<5> Asserts that the method call returned true
<6> Verify that the query method was called on the `MyDatabase` mock

=== Configuring mocks

To configure which values are returned at a method call the Mockito framework defines a fluent API. 
		
The `when(....).thenReturn(....)` method chain is be used to specify a condition and a return value for this condition. 
If you specify more than one value,	they are returned in the order of specification until the last one is used. 
Afterwards the last	specified value	is returned. 
Mocks can also return different values depending on arguments passed into a method. 
You also can use methods like `anyString` or `anyInt` to define that dependent on the input type a certain value should be returned.

[source,java]
----
include::res/api/WhenThenReturn.java[]
----

		
The `doReturn(...).when(...).methodCall` call chain works similar but is useful for void methods. 
The `doThrow` variant can be used for methods which return `void` to throw an exception. 
This usage is demonstrated by the following code snippet.
		

[source,java]
----
include::res/api/doReturnWhen.java[]
----		




[[mockito_verify]]
===	Verify the calls on the mock objects
		
Mockito keeps track of all the method calls and their parameters to the mock object. 
You can use the `verify()` method on the mock object to verify that the specified conditions are met.
For example, you can verify that a method has been called with certain parameters.
This kind of testing is sometimes called _behavior testing_. 
Behavior testing does not check the result of a method call, but it checks that a method is called with the right parameters.
		
[source,java]
----
include::res/api/Verify.java[]
----


[[mockito_spy]]
=== Wrapping Java objects with Spy
		
@Spy or the `spy()` 	method can be used to wrap a real object. 
Every call, unless specified otherwise, is delegated to the object.
		
[source,java]
----
include::res/simple/Spy.txt[]
----		


[[mockito_dependencyinjection]]
=== Using @InjectMocks for dependency injection via Mockito
		
You also have the `@InjectMocks` annotation which tries to do constructor, method or field dependency injection based on the type. 
For example, assume that you have the following class.
		
[source,java]
----
public class ArticleManager {
    private User user;
    private ArticleDatabase database;

    public ArticleManager(User user, ArticleDatabase database) {
        super();
        this.user = user;
        this.database = database;
    }

    public void initialize() {
        database.addListener(new ArticleListener());
    }
}
----		

This class can be constructed via Mockito and its dependencies can be fulfilled with mock objects as demonstrated by the following code snippet.		
[source,java]
----
include::res/snippet/Example.java[]
----		

<1> creates an instance of `ArticleManager` and injects the mocks into it

Mockito can inject mocks either via constructor injection, setter injection, or property injection and in this order.
So if `ArticleManager` would have a constructor that would only take `User` and setters for both fields, only the mock for `User` would be injected.

=== Capturing the arguments

The `ArgumentCaptor` class allows to access the arguments of method calls during the verification.
This allows to capture these arguments of method calls and to use them for tests.

To run this example you need to add https://mvnrepository.com/artifact/org.hamcrest/hamcrest-library[hamcrest-library] to your project.

[source,java]
----
import static org.hamcrest.Matchers.hasItem;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import java.util.Arrays;
import java.util.List;

import org.junit.Rule;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;


public class MockitoTests {
    
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Captor
    private ArgumentCaptor<List<String>> captor;
	
			
    @Test
    public final void shouldContainCertainListItem() {
        List<String> asList = Arrays.asList("someElement_test", "someElement");
        final List<String> mockedList = mock(List.class);
        mockedList.addAll(asList);
            
        verify(mockedList).addAll(captor.capture());
        final List<String> capturedArgument = captor.getValue();
        assertThat(capturedArgument, hasItem("someElement"));
    }
}
----        

=== Process input in stubbed methods

It is possible to process the arguments that where handed to your stubbed method.

[source, java]
----
@Test
public final void answerTest() {
    Incrementor incrementor = mock(Incrementor.class);
    
    when(incrementor.increment(anyInt())).thenAnswer(new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            return ((Integer) args[0]) + 2;
        }
    });
    
    assertNotEquals(Integer.valueOf(11), incrementor.increment(10));
}
----

This can be written more concisely with Java 8 and the `AdditionalAnswers` factory:

[source, java]
----
@Test
public final void answerTest() {
    Incrementor incrementor = mock(Incrementor.class);
    
    when(incrementor.increment(anyInt())).thenAnswer(AdditionalAnswers.answer((Integer integer) -> integer + 2));
    
    assertNotEquals(Integer.valueOf(11), incrementor.increment(10));
}
----


=== Mocking final classes

Since Mockito v2 it is possible to mock final classes.
This feature is incubating and is deactivated by default.
To activate the mocking of final classes create the file `org.mockito.plugins.MockMaker` in either `src/test/resources/mockito-extensions/` or `src/mockito-extensions/`.
Add this line to the file: _mock-maker-inline_.
With this modification we now can mock a final class.

[source, java]
----
final class FinalClass {
    public final String finalMethod() { return "something"; }
}

@Test
public final void mockFinalClassTest() {
     FinalClass instance = new FinalClass(); 

     FinalClass mock = mock(FinalClass.class);
     when(mock.finalMethod()).thenReturn("that other thing");

     assertNotEquals(mock.finalMethod(), instance.finalMethod());
}
----

=== Clean test code with the help of the strict stubs rule


The strict stubs rule helps you to keep your test code clean and checks for common oversights.
It adds the following:

* test fails early when a stubbed method gets called with different arguments than what it was configured for (with `PotentialStubbingProblem` exception).
* test fails when a stubbed method isn't called (with `UnnecessaryStubbingException` exception).
* org.mockito.Mockito.verifyNoMoreInteractions(Object) also verifies that all stubbed methods have been called during the test

[source, java]
----
@Test
public void withoutStrictStubsTest() throws Exception {
    DeepThought deepThought = mock(DeepThought.class);

    when(deepThought.getAnswerFor("Ultimate Question of Life, The Universe, and Everything")).thenReturn(42);
    when(deepThought.otherMethod("some mundane thing")).thenReturn(null);

    System.out.println(deepThought.getAnswerFor("Six by nine"));

    assertEquals(42, deepThought.getAnswerFor("Ultimate Question of Life, The Universe, and Everything"));
    verify(deepThought, times(1)).getAnswerFor("Ultimate Question of Life, The Universe, and Everything");
}
----

[source, java]
----
// activate the strict subs rule
@Rule public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

@Test
public void withStrictStubsTest() throws Exception {
    DeepThought deepThought = mock(DeepThought.class);

    when(deepThought.getAnswerFor("Ultimate Question of Life, The Universe, and Everything")).thenReturn(42);
    // this fails now with an UnnecessaryStubbingException since it is never called in the test
    when(deepThought.otherMethod("some mundane thing")).thenReturn(null);

    // this will now throw a PotentialStubbingProblem Exception since we usually don't want to call methods on mocks without configured behavior
    deepThought.someMethod();

    assertEquals(42, deepThought.getAnswerFor("Ultimate Question of Life, The Universe, and Everything"));
    // verifyNoMoreInteractions now automatically verifies that all stubbed methods have been called as well
    verifyNoMoreInteractions(deepThought);
}
---- 

		
[[mockito_limitations]]
=== Limitations
		
Mockito has certain limitations. 
It can not test the following constructs:

* anonymous classes
* primitive types


